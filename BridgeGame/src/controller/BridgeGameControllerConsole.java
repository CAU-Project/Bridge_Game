package controller;

import java.util.Scanner;

import model.Board;
import model.Cell;
import model.Die;
import model.Player;

public class BridgeGameControllerConsole {
	Scanner sc = new Scanner(System.in);
	
	Die die;
	private int faceValue;
	private int numPlayer;
	private int turn;
	private int selection;
	private int leftPlayer;
	private String mapName;
	private Board board;
	private Player players[];
	
	
	public BridgeGameControllerConsole() {
		init();
		playGame();
	}
	
	public void init() {
		System.out.println("게임을 플레이 할 사용자 수를 입력해 주세요.");
		System.out.print(">>>");
		numPlayer = sc.nextInt();
		leftPlayer = numPlayer;
		
		System.out.println("플레이 할 맵의 이름을 입력해 주세요.");
		System.out.print(">>>");
		mapName = sc.next();
		//mapName = new String("default");
				
		/*Board, Die, Player 객체 생성*/
		board = new Board(mapName);
		die = new Die();
		players = new Player[numPlayer];
		for(int i=1; i<numPlayer + 1; i++ ) {
			players[i-1] = new Player(board.getStartCell().getX(), board.getStartCell().getY(), i);
			players[i-1].setCurrentCell(board.getStartCell());
			players[i-1].setBoard(board);
		}
		
		
		turn = 0;

		
	}
	
	public void playGame() {
		while(leftPlayer > 1) {
			if(players[turn].getIsFinish()) {
				turn = (turn + 1) % numPlayer;
				continue;
			}
			
			printBoard();
			printCurrentPlayerInfo();
			// 0. 주사위를 굴릴지 아니면 턴을 넘길지 선택
			printSelection();
			System.out.print(">>> ");
			selection = sc.nextInt();
			
			// 1.a. 해당 턴을 종료를 선택
			if(selection == 2) {
				// 다리 카드 하나 줄이고 턴을 종료
				players[turn].decreaseBridgeCard();
				turn = (turn + 1) % numPlayer;
				continue;
			}
			
			// 현재 칸이 다리를 건너기 전이면 건널지 유무 판단
			players[turn].checkBridge();
			// 1. 주사위 굴리기
			die.rollDie();
			faceValue = die.getFaceValue();
			
			// 2. 현재 플레이어가 갈 수 있는 경로 출력해 주기.
			int availableCount = players[turn].calcAvailablePath(faceValue);
			players[turn].printAvailablePath();
			if (availableCount <= 0) {
				turn = (turn + 1) % numPlayer;
				continue;
			}
			while(!players[turn].move()) {
				System.out.println("유효하지 않은 경로를 입력했습니다. 다시 입력하세요.");
				players[turn].printAvailablePath();
			}
			
			// 3. 현재 플레이어가 끝났는지 확인 후, 1,2번 반복
			if(players[turn].getIsFinish()) {
				finishPlayer(players[turn]);
			}
			
			turn = (turn + 1) % numPlayer;

		}
		/*마지막 한명이 남으면 플레이어들의 등수/점수를 화면에 출력하면서 종료*/
		finishGame();	
	}
	
	public void printCurrentPlayerInfo() {
		System.out.println("================== PlayerInfo() ==========================");
		System.out.printf("현재 플레이어 : player%d\n",players[turn].getPlayerId());
		System.out.printf("다리 카드 갯수 : %d\n",players[turn].getBridgeCard());
		System.out.printf("현재 점수 : %d\n",players[turn].getScore());
	}
	
	public void printBoard() {
		
		// 현재 보드위의 상황 출력
		System.out.println("================== printBoard() ==========================");
		Cell cellArray[][] = board.getCellArray();
		for(int i=0; i<Board.MAX_MAP_SIZE;i++) {
			for(int j=0 ; j<Board.MAX_MAP_SIZE; j++) {
				Boolean isPlayer = false;
				int idx=0;
				for(int p=0; p<numPlayer; p++) {
					if(players[p].getX() == i && players[p].getY() == j) {
						isPlayer = true;
						idx = p;
					}
				}
				if(isPlayer) {
					switch (cellArray[i][j].getType()) {
					case Cell.START:
						System.out.printf("\u001B[33m%2d%1c\u001B[0m",players[idx].getPlayerId(),'S');
						break;
					case Cell.END:
						System.out.printf("\u001B[33m%2d%1c\u001B[0m",players[idx].getPlayerId(),'E');
						break;
					case Cell.BLOCKED_CELL:
						System.out.printf("%3c",' ');
						break;
					case Cell.CELL:
						System.out.printf("%2d%1c",players[idx].getPlayerId(),'C');
						break;				
					case Cell.HAMMER:
						System.out.printf("\u001B[35m%2d%1c\u001B[0m",players[idx].getPlayerId(),'H');
						break;
					case Cell.SAW:
						System.out.printf("\u001B[36m%2d%1c\u001B[0m",players[idx].getPlayerId(),'S');
						break;
					case Cell.PHILIPS_DRIVER:
						System.out.printf("\u001B[32m%2d%1c\u001B[0m",players[idx].getPlayerId(),'P');
						break;
					case Cell.BRIDGE_START:
						System.out.printf("\u001B[31m%2d%1c\u001B[0m",players[idx].getPlayerId(),'B');
						break;
					case Cell.BRIDGE_END:
						System.out.printf("%2d%1c",players[idx].getPlayerId(),'b');
						break;
					case Cell.BRIDGE:
						System.out.printf("\u001B[34m%2d%1c\u001B[0m",players[idx].getPlayerId(),'=');
						break;
					
					default:
						break;
					}
					
				}else {
					switch (cellArray[i][j].getType()) {
					case Cell.START:
						System.out.printf("\u001B[33m%3c\u001B[0m",'S');
						break;
					case Cell.END:
						System.out.printf("\u001B[33m%3c\u001B[0m",'E');
						break;
					case Cell.BLOCKED_CELL:
						System.out.printf("%3c",' ');
						break;
					case Cell.CELL:
						System.out.printf("%3c",'C');
						break;				
					case Cell.HAMMER:
						System.out.printf("\u001B[35m%3c\u001B[0m",'H');
						break;
					case Cell.SAW:
						System.out.printf("\u001B[36m%3c\u001B[0m",'S');
						break;
					case Cell.PHILIPS_DRIVER:
						System.out.printf("\u001B[32m%3c\u001B[0m",'P');
						break;
					case Cell.BRIDGE_START:
						System.out.printf("\u001B[31m%3c\u001B[0m",'B');
						break;
					case Cell.BRIDGE_END:
						System.out.printf("%3c",'b');
						break;
					case Cell.BRIDGE:
						System.out.printf("%3c",'=');
						break;
					default:
						break;
					}
				}
			}
			
			System.out.println();
		}
		System.out.println("==========================================================");
	}

	public void printSelection() {
		System.out.println("======= 선택하기 ========");
		System.out.println("1. 이동하기");
		System.out.println("2. 이번턴을 끝내고 다리 카드 한장 제거");
		
		
	}

	public void finishPlayer(Player player) {
		int rank = numPlayer - leftPlayer + 1;
		leftPlayer--;
		
		if(rank == 1) {
			player.setScore(player.getScore() + 7);
		}else if(rank == 2) {
			player.setScore(player.getScore() + 3);
		}else {
			player.setScore(player.getScore() + 1);
		}
		
		System.out.printf("player%d가 %d등으로 도착했습니다.\n",player.getPlayerId(),rank);
		System.out.printf("player%d의 총 획득 점수 : %d\n",player.getPlayerId(),player.getScore());
		
	}

	public void finishGame() {
		System.out.println("================ 게임 종료 ================ ");
		System.out.println("=============== 플레이어 점수 =============== ");
		
		for(int i=0; i < numPlayer; i++) {
			System.out.printf("player%d : %d\n",i+1,players[i].getScore());
		}
		
		
	}
	

}
